
const PNotifications = {}

class PObject {
    // overrides
    listen = state => ({})

    // public methods
    notify = (name, data) => {
        if (PNotifications[name] === undefined) return
        PNotifications[name].forEach(h => {
            if (!h[0](data) && h[1] instanceof View) h[1].refresh()
        })
    }

    // private
    constructor() {
		this.state = {}
    }

    __setupListeners() {
        Object.entries(this.listen(this.state)).forEach(h => {
            if (PNotifications[h[0]] === undefined) PNotifications[h[0]] = []
            PNotifications[h[0]].push([h[1], this])
        })
    }

    __destroyListeners() {
        Object.entries(this.listen(this.state)).forEach(h => {
            let i = PNotifications[h[0]].length
            while (i--) {
                if (PNotifications[h[0]][i][1] === this) PNotifications[h[0]].splice(i, 1)
            }
        })
    }
}

export function view(type, state={}, content="") {
    // fix state and content IF content is passed in as state
    if (typeof state !== "object" || state instanceof HTMLElement || Array.isArray(state)) {
        content = state
        state = {}
    }

    // fix type IF a string is passed in as type
    if (typeof type === "string") {
        state["classes"] = type.split(" ")
        type = View
    }

	if (!type) throw(`PSYSTEM ERROR \n'view(CLASSNAME) failed because CLASSNAME hasn't been imported properly`)
    const object = new type()
    if (!("__init" in object)) throw(`PSYSTEM ERROR \n'${type.name}' or its superclass does not inherit from 'View'`)
    object.__init(state, content)
    return object.dom
}

export class View extends PObject {
    // overrides
    init(s) {}
    layout(s) { return "" }
    classes(s) { return "classes" in this.state ? this.state.classes : [] }
    style(s) { return "style" in this.state ? this.state.style : {} }
    domAttributes(s) { return "domAttributes" in this.state ? this.state.domAttributes : {} }
	tag() { return "tag" in this.state ? this.state.tag : "div" }
	ref() { return "ref" in this.state ? this.state.ref : null }
	disableInitialRefresh() { return "disableInitialRefresh" in this.state ? this.state.disableInitialRefresh : false }
    didAppear() {}
    didDisappear() {}

	// public methods
	setState(s) {
		Object.assign(this.state, s)
		this.refresh()
	}

    refresh(layout="") {
        // refresh the objects domAttributes, style, and classes
        Object.entries(this.domAttributes(this.state)).forEach(k => this.dom.setAttribute(k[0], k[1]))
        Object.entries(this.style(this.state)).forEach(k => this.dom.style[k[0]] = k[1])
        let classes = this.classes(this.state)
        let obj = this.__proto__
        while (obj.constructor != View) {
            classes.push(obj.constructor.name)
            obj = obj.__proto__
        }
        this.dom.className = classes.join(" ")

        // refresh the objects layout
        if (layout === "") layout = this.layout(this.state)
		const frag = document.createDocumentFragment()
		const wasArray = Array.isArray(layout)
        if (!Array.isArray(layout)) layout = [layout]
        layout.flatten().forEach(c => {
            if (c === "" || c === null) return
            else if (typeof c === "string" || typeof c === "number") {
				if (wasArray) frag.appendChild(view('', c))
				else frag.appendChild(document.createTextNode(c))
			} else if (typeof c === "object") frag.appendChild(c)
        })
        this.dom.innerHTML = ""
        this.dom.appendChild(frag)
    }
    
    addEventListener(name, f) {
        this.dom.addEventListener(name, f)
	}
	
	get(ref) {
		// todo make this getDOM and get returns the object
		const v = this.dom.querySelector("#"+ref)
		if (v) return v
		else throw(`PSYSTEM ERROR \nAttempted to get('${ref}') but the element was not loaded in the DOM hierarchy \nMake sure to overload ref() of the target element and call get() after it is loaded in the DOM hierarchy`)
	}

	formData() {
		const r = {}
		for (let i of this.dom.getElementsByClassName("Input")) {
			if (!i.object.ref()) { console.warn("PSYSTEM WARNING ~ formData() found an input with 'ref' unassigned so it was ignored", i); continue }
			r[i.object.ref()] = i.value
		}
		for (let i of this.dom.querySelectorAll("input[type='radio']")) {
			if (i.name == "") { console.warn("PSYSTEM WARNING ~ formData() found an input[type='radio'] with name unassigned so it was ignored", i); continue }
			if (r[i.name] == undefined) r[i.name] = null
			if (i.checked) r[i.name] = i.object.state.value
		}
		return r
	}

	formHasEmpties = () => {
		let has = false
		for (let [k, v] of Object.entries(this.formData())) {
			if (v == null || v == undefined || (typeof(v) == "string" && v.trim() == "")) {
				this.notify("formHasEmpties", { "ref": k })
				has = true
			} else {
				this.notify("formHasEmpties", { "ref": k, "reset": true })
			}
		}
		return has
	}

    get controller() {
        let n = this.dom.parentNode
        while (n) {
            if ("object" in n && n.object instanceof Controller) return n.object
            n = n.parentNode
        }
        return null
    }

    get navController() {
        let n = this.dom.parentNode
        while (n) {
            if ("object" in n && n.object instanceof NavController) return n.object
            n = n.parentNode
        }
        return null
    }

    // ____ PRIVATE
    __init(state, layout) {
        this.state = state
        
		this.dom = document.createElement(this.tag())
		this.dom.object = this
		if (this.ref()) this.dom.id = this.ref()
		this.__setupListeners()

        if ("onClick" in state) this.addEventListener("click", state.onClick)
        else if (this.onClick != undefined) this.addEventListener("click", () => this.onClick())

		this.init(this.state)
		if (!this.disableInitialRefresh()) {
			this.refresh(layout)
		}
    }
}

export class Model {
	// init
	init() {}

	constructor() {
        this.init()
	}

	// properties
	static sessionStorage = JSON.parse(window.sessionStorage.getItem("PSystemSessionStorage")) || {}
	static localStorage = JSON.parse(window.localStorage.getItem("PSystemLocalStorage")) || {}
	
	// methods
	static request(method, url, data, callback) {
		// todo throw cannot send body data in GET requests
		const xhr = new XMLHttpRequest()
		xhr.open(method, url, true)
		xhr.setRequestHeader("Content-type", "application/json")
		xhr.onreadystatechange = function() {
		    if (xhr.readyState === 4) callback(JSON.parse(xhr.responseText), xhr.status)
		}
		xhr.send(JSON.stringify(data))
    }

    static saveSessionStorage(obj={}) {
        Object.assign(Model.sessionStorage, obj)
        window.sessionStorage.setItem("PSystemSessionStorage", JSON.stringify(Model.sessionStorage))
    }

    static saveLocalStorage(obj={}) {
        Object.assign(Model.localStorage, obj)
        window.localStorage.setItem("PSystemLocalStorage", JSON.stringify(Model.localStorage))
    }

    static clearSessionStorage() {
        Model.sessionStorage = {}
        window.sessionStorage.removeItem("PSystemSessionStorage")
    }

    static clearLocalStorage() {
        Model.localStorage = {}
        window.localStorage.removeItem("PSystemLocalStorage")
	}

	static clearAllStorage() {
		Model.clearLocalStorage()
		Model.clearSessionStorage()
	}
}

export class Controller extends View {
	navRemoveFromHistory = () => false
	title = () => ""
	preroute = finish => { finish() }
}

export class NavController extends Controller {
	get topController() { return this.dom.children.length > 0 ? this.dom.children[this.dom.children.length-1].object : null }

	router = () => undefined

    route(url, replaceState=false) {
		const v = this.getControllerFor(url)
		if (v != null) {
			v.object.preroute(() => {
				v.object._id = new Date().getTime()
				if (!replaceState && this.topController && !this.topController.navRemoveFromHistory()) window.history.pushState({ url: url, _id: v.object._id  }, v.object.title(), url)
				else window.history.replaceState({ url: url, _id: v.object._id }, v.object.title(), url)
				document.title = v.object.title()
				v.object.refresh()
				this.push(v)
			})
		}
	}
	
	getControllerFor(url) {
        if (this.router() == undefined) return null
        let path = url.split("/"); path.shift()
		const keys = Object.entries(this.router())

        for (let k in keys) { // todo replace this with forEach. causing weird extra element. NotFound does not work
			let match = keys[k][0].split("/"); match.shift()
			if (match.length != path.length) continue
            let found = true
            let state = { disableInitialRefresh: true }
            for (let m in match) {
                if (match[m][0] === ":") {
                    state[match[m].substr(1)] = path[m]
                } else if (match[m] !== path[m]) {
                    found = false
                    break
                }
            }
            if (found) {
				return view(keys[k][1], state)
            }
        }

		if ("NotFound" in this.router()) return view(this.router()["NotFound"])
		throw("PSYSTEM ERROR \nDefine 'NotFound' in router() to handle: " + url)
	}
	
	push(v) {
		if (this.topController) {
			if (this.topController.navRemoveFromHistory()) this.dom.removeChild(this.topController.dom)
			else this.topController.dom.classList.add("Pop")
			document.body.scrollTop = 0 //todo, not necessary causing weird flash on push
		}
		this.dom.appendChild(v)
	}

	pop(_id=null) {
		if (_id == null) {
			if (this.dom.children.length >= 2) _id = this.dom.children[this.dom.children.length-2].object._id
			else return false
		}

		var found = false
		Array.from(this.dom.children).forEach(c => {
			if (found) this.dom.removeChild(c)
			else if (_id == c.object._id) {
				found = true
				c.classList.remove("Pop")
				c.object.didAppear()
				if (this.router() != undefined) document.title = c.object.title()
			}
		})

		if (found) return true
		return false
	}

    // private
    __init(state, layout) {
		super.__init(state, layout)
		if (this.router() != undefined) {
			// this.dom.innerHTML = ""
			this.route(window.location.pathname, true)

			window.addEventListener("popstate", e => {
				if (!this.pop(e.state._id)) {
					this.dom.innerHTML = ""
					this.route(e.state.url, true)
				}
			})
		}
    }
}

export class Image extends View {
	image = s => ""

    style = s => ({
		backgroundImage: `url(${ ("image" in s ? s.image : this.image()) })`
	})
}

export class Button extends View {}


// ADD MUTATION OBSERVER TO WINDOW    
new MutationObserver(mutations => {
	function addedNode(n) {
		if ("object" in n) {
			n.object.didAppear()
			if ("children" in n) n.children.forEach(c=> addedNode(c))
		}
	}
	function removedNode(n) {
		if ("object" in n) {
			n.object.__destroyListeners()
			n.object.didDisappear()
			if ("children" in n) n.children.forEach(c=> removedNode(c))
		}
	}
	mutations.forEach(mutation => {
		mutation.addedNodes.forEach(n => addedNode(n))
		mutation.removedNodes.forEach(n => removedNode(n))
	})
}).observe(document.body, { childList: true, subtree: true }) // TODO maybe someday change this to root node of app


// NODELIST / ARRAY EXTENSIONS
NodeList.prototype.forEach = HTMLCollection.prototype.forEach = Array.prototype.forEach

Array.prototype.flatten = function() {
	let r = []
	this.forEach(d => {
		if (Array.isArray(d)) d = d.flatten()
		r = r.concat(d)
	})
	return r
}

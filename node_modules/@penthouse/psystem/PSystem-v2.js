
// Private Variables
const pNotifications = {}
let pRoot = null
let pListenerId = 0

// Public Functions
window.print = console.log

window.requireApp = function(modules, requires=null) {
	if (!requires) throw(`Error requireApp(module, requires): You must pass the arrow function s => require(s+"") as the second parameter. Require must be called in the scope of your index.js file. We wish it didn't have to be this way.`)
	for (const s of modules) Object.entries(requires(s)).forEach(d => window[d[0]] = d[1])
}

window.startApp = function(type) {
	pRoot = type
}

window.view = (type="", state={}, layout=null) => {
    // fix state and layout IF layout is passed in as state
    if (typeof state !== "object" || state instanceof View || Array.isArray(state)) {
        layout = state
        state = {}
    }

	// fix type IF a string is passed in as type
    if (typeof type === "string") {
        state["class"] = type
        type = View
	}

	if (layout !== null) state["layout"] = layout
    return new type(state)
}


// Private Classes
class PObject {	
    // overrides
    listen = () => ({})

    // public methods
    notify = (name, data) => {
        if (pNotifications[name] === undefined) return
        pNotifications[name].forEach(h => h[0](data))
	}
	
	// private
    _setupListeners() {
		this._listenerIds = []
		for (const [k, v] of Object.entries(this.listen())) {
			if (pNotifications[k] === undefined) pNotifications[k] = []
			pListenerId += 1
			this._listenerIds.push(pListenerId)
			pNotifications[k].push([v, pListenerId])
		}
    }

    _destroyListeners() {
		for (const [k, v] of Object.entries(this.listen())) {
            let i = pNotifications[k].length
            while (i--) {
				if (this._listenerIds.includes(pNotifications[k][i][1])) pNotifications[k].splice(i, 1)
			}
		}
    }
}


// Public Classes
window.View = class View extends PObject {
    // overrides
	init(s) {} // todo delete this three methods? replace them?
	extendState() { return {} }
	getState(s) {
		if (s in this.state) return this.state[s]
		console.warn("Matt needs to change this warning. But it's thrown by getState() and basically is telling you that some state", s, "needs to be set in the target object")
		return undefined
	}
	passthrough() { return this }
	// initState(s) { return {} }
	// overrideState(s) { return {} }
	// config(s) { return {} }
	// didAppear() {}
	// didDisappear() {}
	refreshEnd() {}
	tag() { return "tag" in this.state ? this.state.tag : "div" }
	ref() { return "ref" in this.state ? this.state.ref : null } // todo make this not search on ID, also add wrapper refs to collect complex formData
    layout(s) { return "layout" in this.state ? this.state.layout : null }
    class(s) { return "class" in this.state ? this.state.class : "" }
	style(s) { return "style" in this.state ? this.state.style : {} }
	onClick() { "onClick" in this.state ? this.state.onClick() : false }
	domAttributes(s) { return "domAttributes" in this.state ? this.state.domAttributes : {} }
	eventListeners(s) { 
		return "eventListeners" in this.state ? this.state.eventListeners : {
			"click": e => { // todo remove all this onClick stuff and put it in the button
				if ("onClick" in this.state) this.state.onClick(e)
				else if (this.onClick != undefined) this.onClick(e)
			}
		}
	}

	// public methods
	setState(s) {
		Object.assign(this.state, s)
		this.refresh()
	}
	
	refresh() {
		// CREATE DOM OBJECT IF UNDEFINED
		if (this.dom == undefined) {
			this.dom = document.createElement(this.tag())
			this.dom.object = this
			if (this.ref()) this.dom.id = this.ref()

			for (const [k, v] of Object.entries(this.eventListeners())) this.dom.addEventListener(k, v, false)
			// this.state = Object.assign(Object.assign(this.initState(this.state), this.overrideState(this.state)), this.state)
			let proto = this.__proto__
			while (proto.constructor != View) {
				this.state = Object.assign(proto.extendState(), this.state)
				proto = proto.__proto__
			}
			// print(this.state)
			// print(this.__proto__.__proto__)
			// print(this.__proto__)
			this.init(this.state)
		}

		// refresh domAttributes, style, and classes
		for (const [k, v] of Object.entries(this.domAttributes(this.state))) this.dom.setAttribute(k, v)
		for (const [k, v] of Object.entries(this.style(this.state))) this.dom.style.setProperty(k, v)
        let className = this.class(this.state) // todo make this not overwrite added and removed classes somehow
        let obj = this.__proto__
        while (obj.constructor != View) {
            className += ` ${obj.constructor.name}`
            obj = obj.__proto__
        }
        this.dom.className = className.trim()

		// prepare layout
		const frag = document.createDocumentFragment()
		let layout = this.layout(this.state)
		if (typeof layout === "string" || typeof layout === "number") {
			frag.appendChild(document.createTextNode(layout))
		} else if (Array.isArray(layout)) {
			if (typeof layout[0] == "function") layout = [layout]
			layout.forEach(c => {
				if (c === null || c === undefined || c === "") return
				else if (typeof c === "string" || typeof c === "number") {
					frag.appendChild([View, c].viewify().dom)
				} else if (Array.isArray(c)) {
					frag.appendChild(c.viewify().dom)
				}
			})
		}

        this.dom.textContent = ""
		this.dom.appendChild(frag)
		this.refreshEnd()
    }
	
	get(ref) {
		const v = this.dom.querySelector("#"+ref)
		if (v) return v.object
		else throw(`PSYSTEM ERROR \nAttempted to get('${ref}') but the element was not loaded in the DOM hierarchy \nMake sure to overload ref() of the target element and call get() after it is loaded in the DOM hierarchy`)
	}

	getDOM(ref) {
		return this.get(ref).dom
	}

	formData() {
		const r = {}
		for (let i of this.dom.getElementsByClassName("Input")) {
			if (!i.object.ref()) { console.warn("PSYSTEM WARNING ~ formData() found an input with 'ref' unassigned so it was ignored", i); continue }
			r[i.object.ref()] = i.value
		}
		for (let i of this.dom.querySelectorAll("input[type='radio']")) {
			if (i.name == "") { console.warn("PSYSTEM WARNING ~ formData() found an input[type='radio'] with name unassigned so it was ignored", i); continue }
			if (r[i.name] == undefined) r[i.name] = null
			if (i.checked) r[i.name] = i.object.state.value
		}
		return r
	}

	formHasEmpties = () => {
		let has = false
		for (let [k, v] of Object.entries(this.formData())) {
			if (v == null || v == undefined || (typeof(v) == "string" && v.trim() == "")) {
				this.notify("formHasEmpties", { "ref": k })
				has = true
			} else {
				this.notify("formHasEmpties", { "ref": k, "reset": true })
			}
		}
		return has
	}

	get children() {
		return Array.from(this.dom.children).map(d => d.object)
	}

	get parent() {
        return this.dom.parentNode ? this.dom.parentNode.object : null
    }

    get controller() {
        let n = this.dom.parentNode
        while (n) {
            if ("object" in n && n.object instanceof Controller) return n.object
            n = n.parentNode
        }
    }

    get navController() {
        let n = this.dom.parentNode
        while (n) {
            if ("object" in n && n.object instanceof NavController) return n.object
            n = n.parentNode
        }
		return null
    }

	// ____ PRIVATE
	constructor(state) {
		super(state)
		this.state = state
	}

	// _destroy() {
	// 	this.state = null
	// 	this.dom.object = null
	// 	this.dom = null
	// }
}

window.Controller = class Controller extends View {
	class(s) { return "top noShrink" }
	removeFromHistory = () => false
	title = () => ""
	preroute = ready => { ready() }
}

window.NavController = class NavController extends Controller {
	animationDuration = () => 0

	get topController() {
		const d = this.controllers.reverse()[0]
		return d
		// return d ? d.object : null
	}

	get secondController() { 
		const d = this.controllers.reverse()[1]
		return d
		// return d ? d.object : null
	}

	get controllers() {
		return Array.from(this.dom.children).filter(d => "wasPushed" in d.object && !d.classList.contains("push")).map(d => d.object)
	}

	router = () => undefined
	didPush(controller) {}
	didPop(controller) {}

    route(url, replaceState=false) {
		const pushing = this.getControllerFor(url)
		if (!pushing) return

		pushing.routeId = Math.round(Math.random() * 100000)
		pushing.preroute(() => {
			if (!replaceState && this.topController && !this.topController.removeFromHistory()) window.history.pushState({ url: url, routeId: pushing.routeId  }, pushing.title(), url)
			else window.history.replaceState({ url: url, routeId: pushing.routeId }, pushing.title(), url)
			document.title = pushing.title()
			// pushing.object.refresh()
			this.push(pushing)
		})
	}
	
	getControllerFor(url) {
        if (this.router() == undefined) throw("PSYSTEM: Attempting to route with NavController.router() unimplemented")
        let path = url.split("/"); path.shift()

        for (const [k, v] of Object.entries(this.router())) {
			let match = k.split("/");
			match.shift()
			if (match.length != path.length) continue
            let found = true
            let state = {}
            for (let m in match) {
                if (match[m][0] === ":") {
                    state[match[m].substr(1)] = path[m]
                } else if (match[m] !== path[m]) {
                    found = false
                    break
                }
            }
            if (found) return view(v, state)
        }

		if ("NotFound" in this.router()) return view(this.router()["NotFound"])
		throw("PSYSTEM ERROR \nDefine 'NotFound' in router() to handle: " + url)
	}
	
	push(pushing) {
		// const popping = this.topController ? this.topController.dom : null
		const popping = this.topController

		pushing.wasPushed = true
		pushing.refresh()

		if (popping) {
			pushing.dom.classList.add("animating")
			pushing.dom.classList.add("push")
		}
		
		this.dom.appendChild(pushing.dom)

		if (popping) {
			setTimeout(() => pushing.dom.classList.remove("push"))
			setTimeout(() => pushing.dom.classList.remove("animating"), this.animationDuration())

			popping.dom.classList.add("animating")
			popping.dom.classList.add("pop")
			setTimeout(() => {
				if (popping.removeFromHistory()) this.dom.removeChild(popping.dom)
				else popping.dom.classList.add("popped")
			}, this.animationDuration())
		}

		this.didPush(pushing)
	}

	pop(popping=null) {
		const pushing = this.topController

		if (!popping) popping = this.secondController
		if (!popping || popping == pushing) return

		popping.dom.classList.remove("popped")
		setTimeout(() => popping.dom.classList.remove("pop"))
		setTimeout(() => popping.dom.classList.remove("animating"), this.animationDuration())

		pushing.dom.classList.add("animating")
		pushing.dom.classList.add("push")
		setTimeout(() => this.dom.removeChild(pushing.dom), this.animationDuration())

		let found = false // if history items are skipped, delete them
		// Array.from(this.dom.children).forEach(p => {
		// 	if (p == popping) found = true
		// 	else if (p == pushing) return
		// 	else if (found && !p.classList.contains("push")) {
		// 		console.log(p)
		// 		this.dom.removeChild(p)
		// 	}
		// })
		this.controllers.forEach(c => {
			if (c == pushing) return
			else if (found) this.dom.removeChild(c.dom)
			else if (c == popping) found = true
		})

		if (this.router() != undefined) document.title = popping.title()
		this.didPop(popping)
	}

	getControllerForRouteId(routeId) {
		for (const c of this.controllers) {
			if (c.routeId == routeId) return c
		}
		return null
	}

	onPopStateHandler = e => {
		const popping = this.getControllerForRouteId(e.state.routeId)
		if (popping) this.pop(popping)
		else this.route(e.state.url, true)
	}

    refreshEnd() {
		if (this.state.root != undefined) {
			this.push(this.state.root)
		} else if (this.router() != undefined) {
			window.removeEventListener("popstate", this.onPopStateHandler)
			window.addEventListener("popstate", this.onPopStateHandler)
			this.route(window.location.pathname, true)
		}
	}
}

window.Model = class Model extends PObject {
	constructor() {
		this.__setupListeners
	}

	// properties
	static sessionStorage = JSON.parse(window.sessionStorage.getItem("PSystemSessionStorage")) || {}
	static localStorage = JSON.parse(window.localStorage.getItem("PSystemLocalStorage")) || {}
	
	// methods
	static request(method, url, data, callback) {
		// todo throw cannot send body data in GET requests
		const xhr = new XMLHttpRequest()
		xhr.open(method, url, true)
		xhr.setRequestHeader("Content-type", "application/json")
		xhr.onreadystatechange = function() {
		    if (xhr.readyState === 4) callback(JSON.parse(xhr.responseText), xhr.status)
		}
		xhr.send(JSON.stringify(data))
    }

    static saveSessionStorage(obj={}) {
        Object.assign(Model.sessionStorage, obj)
        window.sessionStorage.setItem("PSystemSessionStorage", JSON.stringify(Model.sessionStorage))
    }

    static saveLocalStorage(obj={}) {
        Object.assign(Model.localStorage, obj)
        window.localStorage.setItem("PSystemLocalStorage", JSON.stringify(Model.localStorage))
    }

    static clearSessionStorage() {
        Model.sessionStorage = {}
        window.sessionStorage.removeItem("PSystemSessionStorage")
    }

    static clearLocalStorage() {
        Model.localStorage = {}
        window.localStorage.removeItem("PSystemLocalStorage")
	}

	static clearAllStorage() {
		Model.clearLocalStorage()
		Model.clearSessionStorage()
	}
}


// EXTENSIONS
NodeList.prototype.forEach = HTMLCollection.prototype.forEach = Array.prototype.forEach

Array.prototype.flatten = function() {
	let r = []
	this.forEach(d => {
		if (Array.isArray(d)) d = d.flatten()
		r = r.concat(d)
	})
	return r
}

Array.prototype.viewify = function() {
	let type = this[0]
	let state = {}

	if (this.length == 2) {
		if (typeof this[1] === "object" && !Array.isArray(this[1])) state = this[1]
		else state["layout"] = this[1]
	} else if (this.length == 3) {
		state = this[1]
		state["layout"] = this[2]
	}

	if (typeof type === "string") {
		state["class"] = type
		type = View
	}

	const v = new type(state)
	v.refresh()
	return v
}

Math.clamp = function(x, min, max) {
	return Math.min(Math.max(x, min), max)
}

Math.distance = function(p1, p2) {
	const a = p1["x"] - p2["x"]
	const b = p1["y"] - p2["y"]
	return Math.sqrt(a * a + b * b)
}

Math.lerp = function(p1, p2, progress) {
	const v = p1 + (p2-p1) * progress
	if (p2 >= p1) return Math.max(Math.min(v, p2), p1)
	else return Math.min(Math.max(v, p2), p1)
}


// Mouse
window.Mouse = class Mouse {
	static position = null
	static positionStart = null
	static positionDrag = null
	static positionLast = null
	static positionMomentum = null

	static getDistance(p1, p2) {
		const a = p1["x"] - p2["x"]
		const b = p1["y"] - p2["y"]
		return Math.sqrt(a * a + b * b)
	}

	static lerp(p1, p2, progress) {
		const v = p1 + (p2-p1) * progress
		if (p2 >= p1) return Math.max(Math.min(v, p2), p1)
		else return Math.min(Math.max(v, p2), p1)
	}

	static mouseDown(e) {
		if ("touches" in e) Mouse.position = { x: e.touches[0].clientX, y: e.touches[0].clientY }
		else Mouse.position = { x: e.clientX, y: e.clientY }

		Mouse.positionStart = Mouse.position
		if (pNotifications["touchDown"]) pNotifications["touchDown"].forEach(h => h[0](e.srcElement))
	}

	static mouseUp(e) {
		if (Mouse.positionDrag) {
			if (pNotifications["touchDragEnd"]) pNotifications["touchDragEnd"].forEach(h => h[0](Mouse.positionDrag))
		}

		if (pNotifications["touchUp"]) pNotifications["touchUp"].forEach(h => h[0](Mouse.positionDrag))
		Mouse.positionDrag = null
		Mouse.positionStart = null
	}

	static mouseMove(e) {
		Mouse.positionLast = Mouse.position

		if ("touches" in e) Mouse.position = { x: e.touches[0].clientX, y: e.touches[0].clientY }
		else Mouse.position = { x: e.clientX, y: e.clientY }
		if (Mouse.positionLast) Mouse.positionMomentum = { x: Mouse.position.x - Mouse.positionLast.x, y: Mouse.position.y - Mouse.positionLast.y }

		if (Mouse.positionStart && !Mouse.positionDrag && Math.distance(Mouse.position, Mouse.positionStart) > 3) {
			let direction = ""
			if (Math.abs(Mouse.position.x-Mouse.positionStart.x) >= Math.abs(Mouse.position.y-Mouse.positionStart.y)) {
				// if (Mouse.position.x-Mouse.positionStart.x > 0) direction = "right"
				// else direction = "left"
				direction = "horizontal"
			} else {
				// if (Mouse.position.y-Mouse.positionStart.y > 0) direction = "down"
				// else direction = "up"
				direction = "vertical"
			}

			Mouse.positionStart = Mouse.position
			Mouse.positionDrag = { x: 0, y: 0, direction: direction }

			if (pNotifications["touchDragStart"]) pNotifications["touchDragStart"].forEach(h => h[0](Mouse.positionDrag, e.srcElement))
			window.requestAnimationFrame(Mouse.mouseDragging)
		}
	}

	static mouseDragging() {
		if (!Mouse.positionDrag) return
		Mouse.positionDrag.x += ((Mouse.position.x - Mouse.positionStart.x) - Mouse.positionDrag.x) * 0.6
		Mouse.positionDrag.y += ((Mouse.position.y - Mouse.positionStart.y) - Mouse.positionDrag.y) * 0.6
		Mouse.positionDrag.x = Math.round(Mouse.positionDrag.x * 100) / 100 
		Mouse.positionDrag.y = Math.round(Mouse.positionDrag.y * 100) / 100
		Mouse.positionDrag.momentum = { x: Mouse.positionDrag.x + Mouse.positionMomentum.x*18, y: Mouse.positionDrag.y + Mouse.positionMomentum.y*18 }
		if (pNotifications["touchDrag"]) pNotifications["touchDrag"].forEach(h => h[0](Mouse.positionDrag))
		window.requestAnimationFrame(Mouse.mouseDragging)
	}
}


// RESIZE HANDLER
const resizeHandler = () => {
	if (window.innerWidth >= 1100) {
		document.documentElement.classList.add("tablet")
		document.documentElement.classList.add("desktop")
	} else if (window.innerWidth >= 600) {
		document.documentElement.classList.add("tablet")
		document.documentElement.classList.remove("desktop")
	} else {
		document.documentElement.classList.remove("tablet")
		document.documentElement.classList.remove("desktop")
	}
}


// WINDOW ONLOAD
window.onload = () => {
	resizeHandler()
	window.addEventListener("resize", resizeHandler, false)
	window.addEventListener("mousedown", Mouse.mouseDown, false)
	window.addEventListener("mouseup", Mouse.mouseUp, false)
	window.addEventListener("mousemove", Mouse.mouseMove, false)
	window.addEventListener("touchstart", Mouse.mouseDown, false)
	window.addEventListener("touchend", Mouse.mouseUp, false)
	window.addEventListener("touchmove", Mouse.mouseMove, false)

	new MutationObserver(mutations => {
		function addedNode(n) {
			if ("object" in n) {
				n.object._setupListeners()
				// n.object._didAppear()
				if ("children" in n) n.children.forEach(c=> addedNode(c))
			}
		}
		function removedNode(n) {
			if ("object" in n) {
				n.object._destroyListeners()
				// n.object._destroy()
				// n.object.didDisappear()
				if ("children" in n) n.children.forEach(c=> removedNode(c))
			}
		}
		mutations.forEach(mutation => {
			mutation.addedNodes.forEach(n => addedNode(n))
			mutation.removedNodes.forEach(n => removedNode(n))
		})
	}).observe(document.body, { childList: true, subtree: true }) // TODO maybe someday change this to root node of app

	// START APP
	if (pRoot) {
		const v = view(pRoot)
		v.refresh()
		document.body.appendChild(v.dom)
	}
}
